<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Japan Saved Places Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      .leaflet-tooltip.place-label {
        font-size: 0.85rem;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      const MAP_BOUNDS_JAPAN = L.latLngBounds(
        [20.214581, 122.93457],
        [45.711204, 154.205541]
      );

      const map = L.map("map", {
        zoomControl: true,
        minZoom: 4,
        maxZoom: 17,
        maxBounds: MAP_BOUNDS_JAPAN.pad(0.25),
      }).setView([36.2048, 138.2529], 5);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19,
      }).addTo(map);

      const savedPlacesUrl = `../data/GoogleMaps/SavedPlacesJP.json?v=${Date.now()}`;
      const matchesUrl = `../data/photos/place_photo_matches.json?v=${Date.now()}`;

      const isValidCoordinate = (coords) =>
        Array.isArray(coords) &&
        coords.length === 2 &&
        typeof coords[0] === "number" &&
        typeof coords[1] === "number" &&
        !(coords[0] === 0 && coords[1] === 0);

      Promise.all([
        fetch(savedPlacesUrl).then((response) => {
          if (!response.ok) {
            throw new Error(`Failed to load ${savedPlacesUrl}`);
          }
          return response.json();
        }),
        fetch(matchesUrl)
          .then((response) => (response.ok ? response.json() : null))
          .catch(() => null),
      ])
        .then(([geojson, matches]) => {
          const visitedLookup = new Map();
          const unmatchedPhotos = [];
          if (matches && Array.isArray(matches.matches)) {
            for (const entry of matches.matches) {
              const place = entry.place || {};
              const photos = entry.photos || [];
              if (!photos.length) continue;
              const key = place.google_maps_url || place.name;
              if (!key) continue;
              const timestamps = photos
                .map((p) => p.timestamp)
                .filter(Boolean)
                .sort();
              const summary = {
                count: photos.length,
                earliest: timestamps[0] || null,
                latest: timestamps[timestamps.length - 1] || null,
              };
              visitedLookup.set(key, summary);
            }
            if (Array.isArray(matches.unmatched_photos)) {
              for (const photo of matches.unmatched_photos) {
                const coords = photo.coordinates;
                if (!Array.isArray(coords) || coords.length !== 2) continue;
                if (!isValidCoordinate([coords[1], coords[0]])) continue;
                unmatchedPhotos.push(photo);
              }
            }
          }

          const filtered = {
            type: "FeatureCollection",
            features: geojson.features.filter((feature) => {
              const coords = feature?.geometry?.coordinates;
              if (!isValidCoordinate(coords)) {
                return false;
              }
              const [lon, lat] = coords;
              return MAP_BOUNDS_JAPAN.contains([lat, lon]);
            }),
          };

          const markers = L.geoJSON(filtered, {
            pointToLayer: (feature, latlng) => {
              const key =
                feature.properties.google_maps_url || feature.properties.location?.name;
              const isVisited = visitedLookup.has(key);
              return L.circleMarker(latlng, {
                radius: 5,
                fillColor: isVisited ? "#2f9e44" : "#eb5757",
                color: isVisited ? "#1b5e20" : "#b91c1c",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8,
              });
            },
            onEachFeature: (feature, layer) => {
              const props = feature.properties || {};
              const location = props.location || {};
              const name = location.name || "Unnamed";
              const address = location.address || "Address unavailable";
              const date = props.date ? new Date(props.date).toLocaleString() : null;
              const category = props.category || "place";
              const listType = props.saved_list || "star";
              const key = props.google_maps_url || location.name;
              const visitSummary = key ? visitedLookup.get(key) : null;

              const popupLines = [
                `<strong>${name}</strong>`,
                address,
              ];

              if (props.prefecture) {
                popupLines.push(`Prefecture: ${props.prefecture}`);
              }

              if (date) {
                popupLines.push(`<small>Saved: ${date}</small>`);
              }

              popupLines.push(
                `<small>Category: ${category}&nbsp;&nbsp;List: ${listType}</small>`
              );

              if (props.visited !== null) {
                const visitedLabel = props.visited ? "Yes" : "No";
                const visitedDate = props.visited_date ? ` (${props.visited_date})` : "";
                popupLines.push(`<small>Visited: ${visitedLabel}${visitedDate}</small>`);
              } else if (visitSummary) {
                const earliest = visitSummary.earliest
                  ? new Date(visitSummary.earliest).toLocaleString()
                  : "n/a";
                const latest = visitSummary.latest
                  ? new Date(visitSummary.latest).toLocaleString()
                  : "n/a";
                popupLines.push(
                  `<small>Photos nearby: ${visitSummary.count} (range ${earliest} â€“ ${latest})</small>`
                );
              }

              if (props.tabelog_rating) {
                popupLines.push(`<small>Tabelog rating: ${props.tabelog_rating}</small>`);
              }

              if (props.notes) {
                popupLines.push(`<em>${props.notes}</em>`);
              }

              if (props.google_maps_url) {
                popupLines.push(
                  `<a href="${props.google_maps_url}" target="_blank" rel="noopener">Open in Google Maps</a>`
                );
              }

              layer.bindPopup(popupLines.join("<br />"));
              layer.bindTooltip(name, { direction: "top", className: "place-label" });
            },
          }).addTo(map);

          if (markers.getBounds().isValid()) {
            map.fitBounds(markers.getBounds().pad(0.05));
          }

          if (unmatchedPhotos.length) {
            const photoLayer = L.layerGroup(
              unmatchedPhotos.map((photo) => {
                const [lon, lat] = photo.coordinates;
                const marker = L.circleMarker([lat, lon], {
                  radius: 4,
                  fillColor: "#1c7ed6",
                  color: "#0b4b94",
                  opacity: 1,
                  fillOpacity: 0.6,
                  weight: 1,
                });
                const timestamp = photo.timestamp
                  ? new Date(photo.timestamp).toLocaleString()
                  : "Unknown";
                const pathDisplay = photo.directory
                  ? `${photo.directory}/${photo.filename}`
                  : photo.filename;
                marker.bindPopup(
                  [
                    `<strong>Photo</strong>`,
                    `File: ${pathDisplay || 'n/a'}`,
                    `Taken: ${timestamp}`,
                  ].join('<br />')
                );
                return marker;
              })
            ).addTo(map);

            L.control.layers(null, { 'Photos (unmatched)': photoLayer }, { collapsed: true }).addTo(map);
          }
        })
        .catch((error) => {
          console.error(error);
          alert(`Unable to load saved places: ${error.message}`);
        });
    </script>
  </body>
</html>
